---
layout: post
title: "Overview of the Basic ECS Structures" 
description: I've finished most of the fundamental structures for ECS-based design. The next stage is putting those structures to use.
author: "Isaac Lichter" 
image: "gooey.png"
parallax: true
---

Hello everyone! Over the past two weeks, I have developed most of a framework for implementing [Entity-Component-System](https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture) architecture in Destination: Sol. Here's a breakdown of what I've done so far:

[My first sub-project](https://github.com/MovingBlocks/DestinationSol/pull/515/files) was making a way to handle damage. First, an entity is assigned a [Health](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/main/java/org/destinationsol/components/Health.java) component. The component contains information about the maximum and current health that the entity has. When the entity receives damage, like when it gets hit by a projectile, a [Damage Event](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/main/java/org/destinationsol/events/DamageEvent.java) is sent to the entity. That event is then processed by the [Damage System](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/main/java/org/destinationsol/systems/DamageSystem.java), which subtracts an amount of health from the entity equal to the damage amount. To ensure that the system works properly, I created [three](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/test/java/org/destinationsol/systems/DamageSystemTests/OnDamageTest.java) [unit](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/test/java/org/destinationsol/systems/DamageSystemTests/NonNegativeHealthTest.java) [tests](https://github.com/IsaacLic/DestinationSol/blob/ecsImplementation/engine/src/test/java/org/destinationsol/systems/DamageSystemTests/NonNegativeDamageTest.java).

Developing the health/damage system was relatively smooth. There was just one issue: when I ran the tests all at once, they didn't pass. When they were run individually, though, they all passed. The issue was that the three tests were sharing information about the systems registered to process events, but they were also each registering the Damage System. What that meant was that there were three copies of the Damage System, so the Damage Event was processed three times, resulting in triple damage. Once that issue was fixed, the tests all passed, even when run together.

My next goal went a lot less smoothly. I had to figure out how the `receiveForce()` and `handleContact()` methods worked so that I could refactor them. My first thought was to combine the impact handling from `handleContact()` with `receiveForce()`. After all, force is force, However, I had failed to account for the difference between a continuous force and an impulse (a sudden force).

Force gradually changes the velocity of a body over time. An impulse, on the other hand, creates an instantaneous change. When two objects collide, their change in velocity isn't a slow acceleration. Force, on the other hand, causes a body's velocity to incrementally increase.

Once I had that cleared up, I created Force and Impulse events to represent the two interactions. Unfortunately, the way that I had designed it didn't work with the existing physics engine. I had assumed that I would be processing the velocity change myself. However, Destination: Sol uses libGDX to handle its physics. 

That led to the current structure. In order to work with that framework, I made a [Contact Event](https://github.com/IsaacLic/DestinationSol/blob/forceHandling/engine/src/main/java/org/destinationsol/events/ContactEvent.java) that gets called when the physics engine is about to handle a contact. Afterwards, the impact of that contact is processed by an [Impulse Event](https://github.com/IsaacLic/DestinationSol/blob/forceHandling/engine/src/main/java/org/destinationsol/events/ImpulseEvent.java). Forces are handled by a [Force Event](https://github.com/IsaacLic/DestinationSol/blob/forceHandling/engine/src/main/java/org/destinationsol/events/ForceEvent.java) unless it is [immune to force](https://github.com/IsaacLic/DestinationSol/blob/forceHandling/engine/src/main/java/org/destinationsol/components/ImmuneToForce.java). The [pull request](https://github.com/MovingBlocks/DestinationSol/pull/516) is still open.

I also made a small component for entities that don't need so much processing power. For example, if an asteroid is far off screen, it doesn't need to be checking to see if it collided with anything else. Such entities are put into [stasis](https://github.com/IsaacLic/DestinationSol/blob/stasis/engine/src/main/java/org/destinationsol/components/Stasis.java). That PR can be found [here](https://github.com/MovingBlocks/DestinationSol/pull/518).

[My next goal](https://github.com/MovingBlocks/DestinationSol/pull/519), removal, was much easier. I created two events: A [Destroy Event](https://github.com/IsaacLic/DestinationSol/blob/removal/engine/src/main/java/org/destinationsol/events/DestroyEvent.java), for when an entity gets destroyed, and a [Removal-For-Optimization Event](https://github.com/IsaacLic/DestinationSol/blob/removal/engine/src/main/java/org/destinationsol/events/RemovalForOptimizationEvent.java), for when an entity no longer needs to exist. I then made a [system](https://github.com/IsaacLic/DestinationSol/blob/removal/engine/src/main/java/org/destinationsol/systems/DefaultDestructionSystem.java) to provide a default way to handle those events. I also made tests for [both](https://github.com/IsaacLic/DestinationSol/blob/removal/engine/src/test/java/org/destinationsol/systems/DestructionSystemTests/DestructionTest.java) [events](https://github.com/IsaacLic/DestinationSol/blob/removal/engine/src/test/java/org/destinationsol/systems/DestructionSystemTests/RemovalForOptimizationTest.java).

#not changed yet

This coming week, I will be implementing ECS for the construction of asteroids. Once I finish, developers will be able to easily create asteroids using the ECS framework, which is one step closer to easy development and modding. 

The week after, I will do the same for the Transcendent object, which is the object that represents a player when they go through a StarPort. That code is particularly tangled, so I want to clean it up to make future development easier. I'll post again about my progress in two weeks.